Hello - from c:\Users\Olive\.vscode\extensions\jaredly.reason-vscode-1.7.13\bin.native.exe.hot.exe
Previous log location: C:\Users\Olive\AppData\Local\Temp\lsp.log
Sending notification {"jsonrpc": "2.0", "method": "client/registerCapability", "params": {"registrations": [{"id": "watching", "method": "workspace/didChangeWatchedFiles", "registerOptions": {"watchers": [{"globPattern": "**/bsconfig.json"}, {"globPattern": "**/.merlin"}]}}]}}
Sending response {"id": 0, "jsonrpc": "2.0", "result": {"capabilities": {"textDocumentSync": 1, "hoverProvider": true, "completionProvider": {"resolveProvider": true, "triggerCharacters": ["."]}, "signatureHelpProvider": {"triggerCharacters": ["("]}, "definitionProvider": true, "typeDefinitionProvider": true, "referencesProvider": true, "documentSymbolProvider": true, "codeActionProvider": true, "executeCommandProvider": {"commands": ["reason-language-server.add_to_interface_inner"]}, "codeLensProvider": {"resolveProvider": true}, "documentHighlightProvider": true, "documentRangeFormattingProvider": true, "documentFormattingProvider": true, "renameProvider": true}}}
Read message 
{"jsonrpc":"2.0","method":"initialized","params":{}}
Read message 
{"jsonrpc":"2.0","method":"workspace/didChangeConfiguration","params":{"settings":{"reason_language_server":{"location":"","build_system_override_by_root":{},"refmt":"","lispRefmt":"","mlfmt":"","format_width":80,"per_value_codelens":false,"dependencies_codelens":true,"opens_codelens":true,"show_module_path_on_hover":true,"reloadOnChange":false,"show_debug_errors":false,"autoRebuild":true}}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///c%3A/Users/Olive/OneDrive/Documents/CS%203250%20Programming%20Languages/Homework/catml.ml","languageId":"ocaml","version":1,"text":"(*\n   Homework 4, Problem 2: Completing the CatML interpreter.\n\n   In this OCaml code file you will find the beginning of various functions with\n   TODO tags in the comments, that you must complete to obtain a correct\n   interpreter for the CatML language. This includes the functions: subst, closed, and step.\n\n   Both the tracer and stepper functions (with pretty printing) have been completed\n   for you and can be used for testing examples as you work on the assignment.\n\n   You should renamte this file as catml.ml and submit once completed. Your submission \n   must be executable OCaml code.\n*)\n\n(*\n(1)\n\n  (a) Let f = (Fun y.1 + y) In (f 10) + (f 11)\n    (i)\n      Let f = (Fun y.1 + y) In (f 10) + (f 11) -> ((Fun y.1 + y) 10) + ((Fun y.1 + y) 11) -> (1 + 10) + ((Fun y.1 + y) 11) -> (1 + 10) + (1 + 11) -> 11 + 12 -> 23\n    (ii)\n      No\n    (iii)\n      No\n\n  (b) (Fun x.x + 0) True\n    (i)\n      No\n    (ii)\n      (Fun x.x + 0) True -> True + 0 -/->\n    (iii)\n      No\n\n  (c) ((Fun x.(Fun y.x + y)) 10) False\n    (i)\n      No\n    (ii)\n      ((Fun x.(Fun y.x + y)) 10) False -> (Fun y.False + y) 10 -> False + 10 -/->\n    (iii)\n      No\n\n  (d) Fix m.x.If x = 0 Then True Else Not (m (x − 1))\n    (i)\n      No\n    (ii)\n      Fix m.x.If x = 0 Then True Else Not (m (x − 1)) -/->\n    (iii)\n      No\n\n  (e) (Fix m.x.If x = 0 Then True Else Not (m (x − 1))) 2\n    (i)\n      (Fix m.x.If x = 0 Then True Else Not (m (x − 1))) 2 -> If 2 = 0 Then True Else Not (Fix m.x.If x = 0 Then True Else Not (m (x − 1)) (2 − 1))) -> \n      Not (Fix m.x.If x = 0 Then True Else Not (m (x − 1)) (1)) -> Not (If 1 = 0 Then True Else Not (Fix m.x.If x = 0 Then True Else Not (m (x − 1))) (1 − 1)) -> \n      Not (Not (Fix m.x.If x = 0 Then True Else Not (m (x − 1))) (0)) -> Not (Not (If 0 = 0 Then True Else Not (Fix m.x.If x = 0 Then True Else Not (m (x − 1)) (0 − 1))) ->\n      Not (Not True) -> True\n    (ii)\n      No\n    (iii)\n      No\n\n  (f) (Fix m.x.m (x + 1)) 2\n    (i)\n      No\n    (ii)\n      No\n    (iii)\n      (Fix m.x.m (x + 1)) 2 -> Fix m.x.m (x + 1) (2 + 1) -> Fix m.x.m (x + 1) (3) -> Fix m.x.m (x + 1) (3 + 1) -> Fix m.x.m (x + 1) (4) -> ...\n\n(3)\n\n*)\n\n(*\n   Abstract Syntax\n   ---------------\n  \n   The expr datatype defines the ASTs for CatML. The mapping from CatML concrete syntax\n   to abstract syntax is as follows, in full detail.\n \n   [[True]] = Bool(true)\n   [[False]] = Bool(false)\n   [[n]] = Int(n)           for any integer n\n   [[x]] = Var(Ident(\"x\"))       for any variable x\n   [[e1 + e2]] = Plus([[e1]], [[e2]])\n   [[e1 - e2]] = Minus([[e1]], [[e2]])\n   [[e1 And e2]] = And([[e1]], [[e2]])\n   [[e1 Or e2]] = Or([[e1]], [[e2]])\n   [[Not e]] = Not([[e]])\n   [[If e1 Then e2 Else e3]] = If([[e1]], [[e2]], [[e3]])\n   [[(e1, e2)]] = Pair([[e1]], [[e2]])\n   [[Fst(e)]] = Fst([[e]])\n   [[Snd(e)]] = Snd([[e]])\n   [[e1 e2]] = Appl([[e1]], [[e2]])\n   [[Let x = e1 in e2]] = Let(Ident(\"x\"), [[e1]], [[e2]])\n   [[(Fun x . e)]] = Fun(Ident(\"x\"), [[e]])\n   [[(Fix z . x . e)]] = Fix(Ident(\"z\"), Ident(\"x\"), [[e]])\n*)\n\ntype ident = Ident of string\n\ntype expr =\n     (* boolean expression forms *)\n     Bool of bool | And of expr * expr | Or of expr * expr | Not of expr   \n     (* arithmetic expression forms *)\n   | Int of int | Plus of expr * expr | Minus of expr * expr | Equal of expr * expr  \n     (* functional expression forms *)\n   | Function of ident * expr | Appl of expr * expr | Var of ident\n     (* pairs *)\n   | Pair of expr * expr | Fst of expr | Snd of expr\n     (* other forms *)\n   | If of expr * expr * expr | Let of ident * expr * expr | Fix of ident * ident * expr\n\n\n(* It's sometimes useful to combine Var and Ident constructors*)\nlet var str = Var (Ident str)\n\nexception AssignmentIncomplete\n\n(*\n   TODO: Closed expression check\n   ------------------------------\n\n   Since reduction is defined only on closed expressions, we need to implement\n   a check to ensure that an input expression is closed. Since closure is preserved\n   by reduction, this check can be performed once statically on source code,\n   as in tracer and stepper below.\n   closed : Dast.expr -> Dast.ident list -> bool\n   in : an expression e and an identifier list ilist\n   out : true iff e is closed, assuming every element of ilist is \n         a bound variable\n*)\nlet rec closed e ident_list = \nlet rec closed e ident_list = \n  match e with \n  | Bool e -> true\n  | Int e -> true\n  | Function (ident, e) -> closed e (ident::ident_list)\n  | Pair (e1, e2) -> closed e1 ident_list && closed e2 ident_list\n  | If (e1, e2, e3) -> closed e1 ident_list && closed e2 ident_list && closed e3 ident_list\n  | Var (Ident x) -> List.exists (fun (Ident y) -> x = y) ident_list\n\n(*\n   TODO: Substitution\n   -------------------\n\n   We implement substitution as defined symbolically, to obtain a substution-based\n   semantics in the interpreter.\n  \n   subst : Dast.expr -> Dast.expr -> Dast.ident -> Dast.expr\n   in : expression e1, expression e2, identifier id\n   out : e1[e2/id] \n*)\nlet rec subst e1 e2 id = raise AssignmentIncomplete;;\n\n(*\n   Value predicate\n   ---------------\n\n   Checking whether a given expression is a value is critical for the operational \n   semantics. \n\n   isval : expr -> bool\n   in : expression e\n   out : true iff e is a value\n*)\nlet rec isval = function \n     Int(_) -> true\n   | Bool(_) -> true\n   | Function(_) -> true\n   | Fix(_) -> true\n   | Pair(e1, e2) -> isval e1 && isval e2\n   | _ -> false\n\nexception NotReducible\n(*\n   TODO: Single step reduction\n   ----------------------------\n\n   Single (aka small) step reduction is the heart of the operational semantics. Pattern\n   matching allows a tight connection with the symbolic definition of the semantics.\n   \n   step : expr -> expr\n   in : AST [[e]]\n   out : AST [[e']] such that e -> e' in the operational semantics\n   side effect : exception NotReducible raised if [[e]] isn't reducible in implementation.\n*)\nlet rec step e = match e with\n     Not(Bool(b)) -> Bool(not b)\n   | And(Bool(b1), Bool(b2)) -> Bool(b1 && b2)\n   | Or(Bool(b1), Bool(b2)) -> Bool(b1 || b2)\n   | Not(e) -> Not(step e)\n   | And(e1,e2) -> if isval e1 then And(e1, step e2) else And(step e1, e2)\n   | Or(e1,e2) -> if isval e1 then Or(e1, step e2) else Or(step e1, e2)\n   | Plus(Int(n1), Int(n2)) -> Int(n1 + n2)\n   | Minus(Int(n1), Int(n2)) -> Int(n1-n2)\n   | Equal(Int(n1), Int(n2)) -> Bool(n1 = n2)\n   | Plus(e1,e2) -> if isval e1 then Plus(e1, step e2) else Plus(step e1, e2)\n   | Minus(e1, e2) -> if isval e1 then Minus(e1, step e2) else Minus(step e1, e2)\n   | Equal(e1, e2) -> if isval e1 then Equal(e1, step e2) else Equal(step e1, e2)\n   | If(Bool(true), e, _) -> e\n   | If(Bool(false), _, e) -> e\n   | If(e1, e2, e3) -> If(step e1, e2, e3)\n   | _ -> raise AssignmentIncomplete;;\n\n\nexception StuckExpression;;\n(*\n   Multistep reduction\n   -------------------\n\n   steps : expr -> expr\n   in : AST [[e]]\n   out : [[v]] such that e ->* v in the operational semantics\n*)\nlet rec steps e = if isval e then e else steps (try (step e) with NotReducible -> raise StuckExpression)\n\n\nopen Printf;;\n\n(*\n  prettyPrint : expr -> string\n  in : An expression AST [[e]].\n  out : The concrete expression e in string format.\n*)\nlet rec prettyPrint e = match e with\n   | Bool true -> \"True\"\n   | Bool false -> \"False\"\n   | Int n -> sprintf \"%i\" n\n   | Var(Ident(x)) -> x\n   | And (e1, e2) -> \"(\" ^ (prettyPrint e1) ^ \" And \" ^ (prettyPrint e2) ^ \")\"\n   | Or (e1, e2) -> \"(\" ^ (prettyPrint e1) ^ \" Or \" ^ (prettyPrint e2) ^ \")\"\n   | Not e1 -> \"(Not \" ^ (prettyPrint e1) ^ \")\"\n   | Plus (e1, e2) -> \"(\" ^ (prettyPrint e1) ^ \" + \" ^ (prettyPrint e2) ^ \")\"\n   | Minus (e1, e2) -> \"(\" ^ (prettyPrint e1) ^ \" - \" ^ (prettyPrint e2) ^ \")\"\n   | Equal (e1, e2) -> \"(\" ^ (prettyPrint e1) ^ \" = \" ^ (prettyPrint e2) ^ \")\"\n   | If(e1, e2, e3) -> \"If \" ^ (prettyPrint e1) ^ \n                       \" Then \" ^ (prettyPrint e2) ^\n                       \" Else \" ^ (prettyPrint e3)\n   | Function(Ident(x), e) -> \"(Fun \" ^ x ^ \" . \" ^ (prettyPrint e) ^ \")\"\n   | Fix(Ident(z), Ident(x), e) -> \"(Fix \" ^ z ^ \" . \" ^ x ^ \" . \" ^ (prettyPrint e) ^ \")\"\n   | Let(Ident(x), e1, e2) -> \"Let \" ^ x ^ \" = \" ^ (prettyPrint e1) ^ \" In\\n\" ^ (prettyPrint e2)\n   | Appl(e1, e2) -> (prettyPrint e1) ^ \" \" ^ (prettyPrint e2)\n   | Pair(e1, e2) -> \"(\" ^ (prettyPrint e1) ^ \", \" ^ (prettyPrint e2) ^ \")\"\n   | Fst(e1) -> \n      (match e1 with Pair(_) -> \"Fst\" ^  (prettyPrint e1) \n                  | _ ->  \"Fst(\" ^  (prettyPrint e1) ^ \")\")\n   | Snd(e1) -> \n      (match e1 with Pair(_) -> \"Snd\" ^  (prettyPrint e1) \n                  | _ ->  \"Snd(\" ^  (prettyPrint e1) ^ \")\")\n\n\nexception NotClosed;;\n\n(*\n  pretty_trace : expr -> bool -> unit\n  in : AST [[e]]\n  out : () \n  side effects : prints intermediate expressions (aka the reduction trace) \n    during evaluation; if stepper flag is on, blocks on keystroke between \n    reductions.  \n*)\nlet rec pretty_trace e stepper =\n  (printf \"%s\" (prettyPrint e); if stepper then ignore (read_line()) else ();\n   if (isval e) then (printf \"\\n\"; flush stdout) else\n     try\n       (\n         let e' = step e in\n         (printf \"->\\n\"; flush stdout; pretty_trace e' stepper)\n       )\n     with NotReducible ->  (printf \"  (Bad, Stuck Expression)\\n\"; flush stdout))\n\n(*\n  stepper : expr -> expr\n  in : AST [[e]]\n  out : [[v]] such that e ->* v in the operational semantics\n  side effects : Blocks on keystroke between reductions, prints intermediate \n    expressions (aka the reduction trace) during evaluation; \n    raises NotClosed if e is not closed.     \n*)\nlet rec stepper e = if (closed e []) then (pretty_trace e true) else raise NotClosed ;;\n(*\n  tracer : expr -> expr\n  in : AST [[e]]\n  out : [[v]] such that e ->* v in the operational semantics\n  side effects : prints intermediate expressions (aka the reduction trace) during evaluation; \n    raises NotClosed if e is not closed. \n*)\nlet rec tracer e =  if (closed e []) then (pretty_trace e false) else raise NotClosed;;\n\n\n\n(*\n   TODO: Homework 4, Problem 3(d): Encodings of lists\n\n   Fill in the definitions of isNil, head, tail, and sum as abstract syntax of OCaml\n   and evaluate sum applied to the list [385, 299, -10, 20].\n*)\nlet nil = Pair (Int 0, Int 0)\nlet cons = Function (Ident \"h\", Function (Ident \"t\", \n              Pair (Int 1, Pair (var \"h\", var \"t\"))\n              ))\nlet example = Appl (Appl(cons, Int 385),\n              Appl (Appl(cons, Int 299),\n              Appl (Appl(cons, Int (-10)),\n              Appl (Appl(cons, Int 20), nil))))\nlet isNil = raise AssignmentIncomplete\nlet head = raise AssignmentIncomplete\nlet tail = raise AssignmentIncomplete\nlet sum = raise AssignmentIncomplete\nlet result = print_endline (\"Got: \" ^ prettyPrint(steps (Appl(sum, example))))"}}}
