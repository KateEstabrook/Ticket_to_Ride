Hello - from c:\Users\Olive\.vscode\extensions\jaredly.reason-vscode-1.7.13\bin.native.exe.hot.exe
Previous log location: C:\Users\Olive\AppData\Local\Temp\lsp.log
Sending notification {"jsonrpc": "2.0", "method": "client/registerCapability", "params": {"registrations": [{"id": "watching", "method": "workspace/didChangeWatchedFiles", "registerOptions": {"watchers": [{"globPattern": "**/bsconfig.json"}, {"globPattern": "**/.merlin"}]}}]}}
Sending response {"id": 0, "jsonrpc": "2.0", "result": {"capabilities": {"textDocumentSync": 1, "hoverProvider": true, "completionProvider": {"resolveProvider": true, "triggerCharacters": ["."]}, "signatureHelpProvider": {"triggerCharacters": ["("]}, "definitionProvider": true, "typeDefinitionProvider": true, "referencesProvider": true, "documentSymbolProvider": true, "codeActionProvider": true, "executeCommandProvider": {"commands": ["reason-language-server.add_to_interface_inner"]}, "codeLensProvider": {"resolveProvider": true}, "documentHighlightProvider": true, "documentRangeFormattingProvider": true, "documentFormattingProvider": true, "renameProvider": true}}}
Read message 
{"jsonrpc":"2.0","method":"initialized","params":{}}
Read message 
{"jsonrpc":"2.0","method":"workspace/didChangeConfiguration","params":{"settings":{"reason_language_server":{"location":"","build_system_override_by_root":{},"refmt":"","lispRefmt":"","mlfmt":"","format_width":80,"per_value_codelens":false,"dependencies_codelens":true,"opens_codelens":true,"show_module_path_on_hover":true,"reloadOnChange":false,"show_debug_errors":false,"autoRebuild":true}}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///c%3A/Users/Olive/Downloads/tryocaml.ml","languageId":"ocaml","version":1,"text":"(* CS3250 Programming Languages F25: Homework 2 *)\n\n(* Problem 1 *)\n\n(* 1a: add parentheses to the following type:\n\n    (('a -> 'b) -> 'a option) -> 'b option\n*)\n\n(* 1b: complete the following specification:\n\n    map_option : ('a -> 'b) -> 'a option -> 'b option\n    in: A function f and an object a\n    out: an object (f a) option\n*)\n\n(* 1c: implement map_option *) \n\nlet map_option f a = \n  match a with\n  | None -> None\n  | Some a -> Some (f a)\n\n(* Problem 2 *)\n\ntype nat = Zero | Successor of nat\n\n(*\n    leq_nat : nat -> nat -> bool\n    in: x and y denoting natural numbers m and n respectively\n    out: true iff m <= n\n*)\n(* add implementation here *)\n\nlet rec leq_nat x y =\n  match (x, y) with\n  | (Successor x', Successor y') -> leq_nat x' y'\n  | (Zero, Zero) -> true\n  | (Zero, Successor y') -> true\n  | (Successor x', Zero) -> false \n\n(* Problem 3 *)\n\ntype 'b plist = Nil | Cons of 'b * ('b plist)\nexception EmptyList\n\n(*\n    int_list_lower_bound : int plist -> int\n    in: a list of integers l\n    out: If l is the empty list, raise an EmtpyList exception.\nOtherwise, return the minimum element of l.\n                                           *)\n(* add implementation here *)\n\nlet rec int_list_lower_bound l = \n  match l with \n  | Cons (i, Nil) -> i\n  | Cons (i, l') -> if i < int_list_lower_bound l' then i else int_list_lower_bound l' \n  | Nil -> raise EmptyList \n    \n(* Problem 4 *)\n\n(*\n    list_lower_bound : ('b -> 'b -> bool) -> 'b plist -> 'b\n    in: a comparison operator (leq : 'b -> 'b -> bool)\n        and a list l : 'b plist\n    out: If the list is empty, raise an EmptyList exception.\n         Otherwise, return an element x of l such that, for all other elements y of l,\n         leq x y = True.\n*)\n(* add implementation here *)\n\nlet rec list_lower_bound leq l =\n  match l with\n  | Cons (i, Nil) -> i\n  | Cons (i, l') -> if leq i (list_lower_bound leq l') then i else list_lower_bound leq l'\n  | Nil -> raise EmptyList \n\n(* Problem 5 *)\n\n(*\n    nat_list_lower_bound : nat plist -> nat\n*)\n(* add implementation here *)\n\nlet nat_list_lower_bound l = \n  list_lower_bound leq_nat l \n\n(* Problem 6 *)\n\ntype 'a tree = Leaf of 'a | Node of 'a tree * 'a tree\n\n(* 6a: complete the following specification and implementation *)\n(*\n    depth : 'a tree -> int\n    in: tree \n    out: int depth of tree\n*)\n(* add implementation here *)\n\nlet rec depth t =\n  match t with \n  | Node (e1, e2) -> if (1 + depth e1) > (1 + depth e2) then 1 + depth e1 else 1 + depth e2\n  | Leaf e -> 1\n\n(* 6b: complete the following specification and implementation *)\n(*\n    is_member : [function type]\n    in: x of type 'a and tre of type 'a tree\n    out: boolean for whether x is in the tree\n*)\n(* add implementation here *)\n\nlet rec is_member x t =\n  match t with\n  | Leaf x' -> if x = x' then true else false\n  | Node (e1, e2) -> is_member x e1 || is_member x e2"}}}
